<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星向 (Star Rays)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 禁止移动端双击缩放和长按选中 */
        body {
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0fdfa;
            /* Teal-50 */

            height: 100vh;
            /* fallback */
            height: 100dvh;
        }

        main {
            min-height: 0;
        }

        #game-container {
            width: min(92vw, 600px);
            height: 100%;
            margin: auto;
        }

        #grid-viewport {
            width: 100%;
            height: min(70vh, 100%);
            height: min(70dvh, 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #game-grid {
            box-sizing: border-box;
            display: grid;
            gap: 1px;
            border: 2px solid #5eead4;
            /* Teal-300 */
            background-color: #99f6e4;
            /* Teal-200 gap */
        }

        .cell {
            width: 100%;
            height: 100%;
            min-width: 0;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            font-family: 'Courier New', Courier, monospace;
            font-weight: 700;
            font-size: clamp(14px, calc(var(--cell, 24px) * 0.6), 32px);
            transition: background-color 0.1s, color 0.1s;
            cursor: pointer;
        }

        /* 状态 0: 未知 (白色背景) */
        .cell.unknown {
            background-color: #ffffff;
            color: #111827;
            /* Gray-900 数字 */
        }

        .cell.unknown:hover {
            background-color: #f8fafc;
        }

        /* 状态 1: 已填色 (浅青色背景) */
        .cell.filled {
            background-color: #ccfbf1;
            /* Teal-100 */
            color: #111827;
        }

        /* 状态 3: 标记为空 (灰色背景) */
        .cell.marked-empty {
            background-color: #e5e7eb;
            /* Gray-200 */
            color: #9ca3af;
            /* Gray-400 数字淡化 */
        }

        /* 数字达标 (蓝色高亮) */
        .cell.satisfied {
            color: #2563eb !important;
            /* Blue-600 */
            font-weight: 900;
            text-shadow: 0 0 2px rgba(37, 99, 235, 0.1);
        }

        /* 数字超标 (红色警示) */
        .cell.overloaded {
            color: #ef4444 !important;
            /* Red-500 */
            font-weight: 900;
        }

        /* 胜利时的动画 */
        .cell.win-anim {
            animation: winPulse 0.6s ease-in-out;
            background-color: #34d399 !important;
            /* Emerald-400 */
            color: white !important;
            border-radius: 4px;
            transform: scale(0.95);
        }

        @keyframes winPulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(0.9);
            }

            100% {
                transform: scale(0.95);
            }
        }

        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(3px);
        }

        * {
            -webkit-tap-highlight-color: transparent;
        }

        #game-container,
        #grid-viewport,
        #game-grid,
        .cell,
        button,
        a {
            touch-action: manipulation;
        }
    </style>
</head>

<body class="h-[100dvh] w-screen flex flex-col overflow-hidden text-gray-800" oncontextmenu="return false;">

    <!-- 顶部导航栏 -->
    <header class="flex-none bg-white shadow-sm z-20 flex flex-col">

        <div class="relative w-full max-w-3xl mx-auto px-4 py-3 flex justify-between items-center">

            <a id="profile-link" href="/" class="flex items-center gap-2 group z-10">
                <img src="/avatar.jpg" alt="Avatar"
                    class="w-8 h-8 rounded-full object-cover border border-gray-200 shadow-sm group-hover:opacity-90 transition">
                <div class="hidden sm:flex flex-col">
                    <span data-i18n="back_home" class="text-sm font-bold text-gray-600 group-hover:text-teal-600 transition">回到主页</span>
                </div>
            </a>

            <h1 id="status-text" class="text-xl font-bold text-teal-800 tracking-tight">
                星向
            </h1>

            <div class="flex items-center gap-2 z-10">
                <!-- 语言切换按钮 -->
                <button onclick="toggleLanguage()" class="p-2 rounded-full hover:bg-gray-100 text-gray-600 transition"
                    data-i18n-title="language" title="语言">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="2" y1="12" x2="22" y2="12"></line>
                        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                    </svg>
                </button>

                <button onclick="restartGame()" class="p-2 rounded-full hover:bg-gray-100 text-gray-600 transition"
                    data-i18n-title="restart" title="重新开始">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                        <path d="M3 3v5h5" />
                    </svg>
                </button>

                <button onclick="toggleTutorial()" class="p-2 rounded-full hover:bg-gray-100 text-gray-600 transition"
                    data-i18n-title="tutorial" title="玩法教程">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                </button>

                <button onclick="toggleSettings()" class="p-2 rounded-full hover:bg-gray-100 text-gray-600 transition"
                    data-i18n-title="settings" title="设置">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path
                            d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" />
                        <circle cx="12" cy="12" r="3" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="w-full bg-teal-50/50 border-t border-gray-100">
            <div class="max-w-3xl mx-auto px-4 py-2 flex justify-center items-center gap-8 sm:gap-12 text-sm">

                <div class="flex items-center gap-2">
                    <span data-i18n="label_remaining" class="text-[10px] text-gray-400 uppercase font-bold tracking-wider">剩余</span>
                    <span id="remain-count" class="text-lg font-bold text-teal-600 leading-none tabular-nums">0</span>
                </div>

                <div class="flex items-center gap-2">
                    <span data-i18n="label_time" class="text-[10px] text-gray-400 uppercase font-bold tracking-wider">时间</span>
                    <span id="timer-display"
                        class="font-mono font-bold text-gray-700 leading-none tabular-nums">00:00</span>
                </div>

                <div class="flex items-center gap-2">
                    <span data-i18n="label_best" class="text-[10px] text-gray-400 uppercase font-bold tracking-wider">最佳</span>
                    <span id="best-time-display"
                        class="font-mono font-bold text-gray-400 leading-none tabular-nums">--:--</span>
                </div>

            </div>
        </div>
    </header>

    <!-- 游戏主区域 -->
    <main class="flex-grow flex items-center justify-center p-2 sm:p-6 overflow-hidden relative flex-col">
        <div id="game-container" class="flex flex-col h-full justify-center">
            <div id="grid-viewport" class="flex-none">
                <div id="game-grid" class="shadow-xl rounded-sm overflow-hidden"></div>
            </div>

            <div class="w-full max-w-[600px] mx-auto z-10 px-1 flex flex-col gap-2">
                
                <div class="flex justify-end w-full">
                    <button id="mode-toggle-btn" onclick="toggleNumberDisplay()" class="bg-white hover:bg-blue-50 text-blue-600 border-2 border-blue-200 font-bold py-2 px-3 rounded-lg transition text-sm shadow-sm">
                        显示总数
                    </button>
                </div>

                <div class="flex items-center gap-2 w-full">
                    <select id="save-select" class="flex-grow bg-white border-2 border-teal-100 text-teal-800 text-sm rounded-lg p-2 focus:outline-none focus:border-teal-300 transition font-mono">
                        <option value="" disabled selected data-i18n="opt_default">-- 选择回溯点 --</option>
                    </select>
                    
                    <button onclick="loadGame()" class="flex-none bg-teal-100 hover:bg-teal-200 text-teal-700 font-bold py-2 px-4 rounded-lg transition text-sm shadow-sm border border-teal-200">
                        <span data-i18n="btn_undo">回溯</span>
                    </button>
                    
                    <button id="btn-save" onclick="saveGame()" class="flex-none bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg transition text-sm shadow-sm">
                        <span data-i18n="btn_record">记录</span>
                    </button>
                </div>
            </div>
        </div>

        <div class="mt-3 text-center text-xs text-teal-700/60 font-medium pointer-events-none select-none px-4">
            <span class="hidden sm:inline" data-i18n="footer_desktop">左键：填色/取消 | 右键：标记空白/取消</span>
            <span class="inline sm:hidden" data-i18n="footer_mobile">点击：切换填色/空白/未知 | 拖动：标记空白/取消</span>
        </div>
    </main>

    <!-- 设置模态框 -->
    <div id="settings-modal" class="fixed inset-0 modal-backdrop hidden flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-xl shadow-xl p-6 max-w-sm w-full border border-gray-100">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-bold text-gray-900" data-i18n="modal_settings_title">游戏设置</h2>
                <button onclick="toggleSettings()"
                    class="text-gray-400 hover:text-gray-600 p-1 rounded-md hover:bg-gray-100">&times;</button>
            </div>

            <div class="space-y-6">
                <!-- 宽度 -->
                <div>
                    <div class="flex justify-between mb-2">
                        <label class="text-sm font-semibold text-gray-700" data-i18n="lbl_width">网格宽度</label>
                        <span id="val-w" class="text-sm font-bold text-teal-600">5</span>
                    </div>
                    <input type="range" id="input-width" min="5" max="15" value="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-teal-600"
                        oninput="document.getElementById('val-w').innerText = this.value">
                </div>

                <!-- 高度 -->
                <div>
                    <div class="flex justify-between mb-2">
                        <label class="text-sm font-semibold text-gray-700" data-i18n="lbl_height">网格高度</label>
                        <span id="val-h" class="text-sm font-bold text-teal-600">5</span>
                    </div>
                    <input type="range" id="input-height" min="5" max="15" value="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-teal-600"
                        oninput="document.getElementById('val-h').innerText = this.value">
                </div>

                <!-- 密度 -->
                <div>
                    <div class="flex justify-between mb-2">
                        <label class="text-sm font-semibold text-gray-700" data-i18n="lbl_density">填色密度</label>
                        <span id="val-d" class="text-sm font-bold text-teal-600">20%</span>
                    </div>
                    <input type="range" id="input-density" min="10" max="80" value="20" step="5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-teal-600"
                        oninput="document.getElementById('val-d').innerText = this.value + '%'">
                </div>
            </div>

            <div class="mt-8">
                <button onclick="applySettings()" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-4 rounded-lg shadow transition">
                    <span data-i18n="btn_apply">应用并重新开始</span>
                </button>
            </div>
        </div>
    </div>

    <div id="tutorial-modal" class="fixed inset-0 modal-backdrop hidden flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-xl shadow-xl p-6 max-w-sm w-full border border-gray-100 relative animate-fade-in">

            <div class="flex justify-between items-center mb-5">
                <h2 class="text-xl font-bold text-gray-900 flex items-center gap-2" data-i18n="modal_tutorial_title">
                    玩法说明
                </h2>
                <button onclick="toggleTutorial()"
                    class="text-gray-400 hover:text-gray-600 p-1 rounded-md hover:bg-gray-100 transition">&times;</button>
            </div>

            <div class="space-y-4 text-sm text-gray-600 leading-relaxed overflow-y-auto max-h-[60vh]">

                <div class="bg-teal-50 p-3 rounded-lg border border-teal-100">
                    <p class="font-bold text-teal-800 mb-1" data-i18n="tut_goal_title">核心目标</p>
                    <p data-i18n="tut_goal_desc">根据格子上的数字提示，推理并还原隐藏的像素图案。</p>
                </div>

                <div>
                    <p class="font-bold text-gray-800 mb-1" data-i18n="tut_num_title">数字含义</p>
                    <p data-i18n="tut_num_desc">数字代表该格子周围（包含自身）<span class="font-bold text-teal-600">8个方向延伸</span>的连续填色格总数。</p>
                </div>

                <div>
                    <p class="font-bold text-gray-800 mb-1" data-i18n="tut_ctrl_title">操作方式</p>
                    <ul class="list-disc pl-5 space-y-1 text-xs">
                        <li data-i18n="tut_ctrl_desc_pc"><strong>电脑：</strong>左键填色，右键标记空白。</li>
                        <li data-i18n="tut_ctrl_desc_mobile"><strong>手机：</strong>点击格子循环切换状态。</li>
                    </ul>
                </div>
            </div>

            <div class="mt-6">
                <button onclick="toggleTutorial()" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-4 rounded-lg shadow transition">
                    <span data-i18n="btn_got_it">明白啦</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- 国际化配置 (I18N) ---
        const I18N = {
            'zh-CN': {
                app_title: "星向",
                back_home: "回到主页",
                restart: "重新开始",
                tutorial: "玩法教程",
                settings: "设置",
                language: "语言",
                label_remaining: "剩余",
                label_time: "时间",
                label_best: "最佳",
                btn_show_total: "显示总数",
                btn_show_remaining: "显示剩余",
                btn_undo: "回溯",
                btn_record: "记录",
                btn_saved: "已存",
                footer_desktop: "左键：填色/取消 | 右键：标记空白/取消",
                footer_mobile: "点击：切换填色/空白/未知 | 拖动：标记空白/取消",
                modal_settings_title: "游戏设置",
                lbl_width: "网格宽度",
                lbl_height: "网格高度",
                lbl_density: "填色密度",
                btn_apply: "应用并重新开始",
                modal_tutorial_title: "玩法说明",
                tut_goal_title: "核心目标",
                tut_goal_desc: "根据格子上的数字提示，推理并还原隐藏的像素图案。",
                tut_num_title: "数字含义",
                tut_num_desc: "数字代表该格子周围（包含自身）<span class='font-bold text-teal-600'>8个方向延伸</span>的连续填色格总数。",
                tut_ctrl_title: "操作方式",
                tut_ctrl_desc_pc: "<strong>电脑：</strong>左键填色，右键标记空白。",
                tut_ctrl_desc_mobile: "<strong>手机：</strong>点击格子循环切换状态。",
                btn_got_it: "明白啦",
                status_new_record: "新纪录！",
                status_perfect: "完美通关！",
                status_revealed: "已显示答案",
                opt_default: "-- 选择回溯点 --",
                opt_reveal: "显示答案"
            },
            'en-US': {
                app_title: "Star Rays",
                back_home: "Back Home",
                restart: "Restart",
                tutorial: "How to Play",
                settings: "Settings",
                language: "Language",
                label_remaining: "Left",
                label_time: "Time",
                label_best: "Best",
                btn_show_total: "Show Total",
                btn_show_remaining: "Show Remaining",
                btn_undo: "Load",
                btn_record: "Save",
                btn_saved: "Saved",
                footer_desktop: "L-Click: Fill | R-Click: Mark Empty",
                footer_mobile: "Tap: Toggle | Drag: Mark Empty",
                modal_settings_title: "Game Settings",
                lbl_width: "Grid Width",
                lbl_height: "Grid Height",
                lbl_density: "Density",
                btn_apply: "Apply & Restart",
                modal_tutorial_title: "How to Play",
                tut_goal_title: "Goal",
                tut_goal_desc: "Deduce and reveal the hidden pixel art based on numerical hints.",
                tut_num_title: "Numbers",
                tut_num_desc: "The number indicates the count of consecutive filled cells extending in <span class='font-bold text-teal-600'>8 directions</span> (including itself).",
                tut_ctrl_title: "Controls",
                tut_ctrl_desc_pc: "<strong>Desktop:</strong> Left click to fill, Right click to mark empty.",
                tut_ctrl_desc_mobile: "<strong>Mobile:</strong> Tap cells to toggle states.",
                btn_got_it: "Got it!",
                status_new_record: "New Record!",
                status_perfect: "Perfect Clear!",
                status_revealed: "Answer Revealed",
                opt_default: "-- Select Checkpoint --",
                opt_reveal: "Reveal Answer"
            }
        };

        // 默认语言
        let currentLang = 'zh-CN';

        // 获取翻译助手函数
        function t(key) {
            return I18N[currentLang][key] || key;
        }

        // 切换语言
        function toggleLanguage() {
            currentLang = currentLang === 'zh-CN' ? 'en-US' : 'zh-CN';
            document.documentElement.lang = currentLang;
            updateLanguageUI();
        }

        // 更新界面所有文本
        function updateLanguageUI() {
            // 1. 更新带有 data-i18n 的元素
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (I18N[currentLang][key]) {
                    el.innerHTML = I18N[currentLang][key];
                }
            });

            // 2. 更新带有 data-i18n-title 的元素 (Tooltip)
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                if (I18N[currentLang][key]) {
                    el.setAttribute('title', I18N[currentLang][key]);
                }
            });

            // 3. 更新动态文本 (需要逻辑判断的部分)
            updateDynamicText();
        }

        // 处理动态文本的更新 (状态栏标题、模式按钮、下拉框等)
        function updateDynamicText() {
            // 更新标题/状态栏 (如果是特殊状态，保留特殊状态文字的翻译)
            if (!gameState.isPlaying && gameState.currentFilled === gameState.totalToFill && gameState.totalToFill > 0) {
                // 胜利状态 - 这里简单起见，重新检查一次状态或直接由 UI 逻辑驱动，
                // 但为了简化，我们仅在非胜利/非特殊状态下重置为 App Title，
                // 如果是胜利状态，我们在 checkWin 里会覆盖它。
                // 稳妥起见，我们仅在普通状态下重置标题，或者当用户点击切换语言时，我们暂且重置为标题
                // 除非有 flag 记录当前是胜利状态。
                // 简单处理：直接设为标题，除非 checkWin 立即覆盖
                statusTextEl.innerText = t('app_title'); 
            } else if (!gameState.isPlaying && countEl.innerText === "0" && gameState.solutionGrid.length > 0) {
                 // 可能是“显示答案”状态
                 statusTextEl.innerText = statusTextEl.classList.contains('text-gray-500') ? t('status_revealed') : t('app_title');
            } else {
                statusTextEl.innerText = t('app_title');
            }

            // 更新模式按钮
            if (gameState.showRemaining) {
                modeBtnEl.innerText = t('btn_show_remaining');
            } else {
                modeBtnEl.innerText = t('btn_show_total');
            }

            // 更新下拉框中的选项
            // 选项0 (Default)
            const defaultOpt = saveSelectEl.querySelector('option[value=""]');
            if (defaultOpt) defaultOpt.innerText = t('opt_default');

            // 选项中如果有 "显示答案" (Reveal Answer)
            Array.from(saveSelectEl.options).forEach(opt => {
                if (opt.text.includes("显示答案") || opt.text.includes("Reveal Answer")) {
                    // 保持前面的序号不变 (例如 "1. 显示答案")
                    const prefix = opt.text.split('. ')[0]; 
                    opt.innerText = `${prefix}. ${t('opt_reveal')}`;
                }
            });
        }


        // --- 全局配置 ---
        let CONFIG = {
            width: 10,
            height: 10,
            fillDensity: 0.55
        };

        // --- 游戏状态 ---
        let gameState = {
            isPlaying: false,
            solutionGrid: [], // true=填色格, false=非填色格 (答案)
            targetValues: [], // 每个格子的目标数字 (基于答案计算)

            // playerGrid 状态定义:
            // 0: 未知 (Unknown)
            // 1: 已填色 (Filled)
            // 3: 标记为空 (Marked Empty)
            playerGrid: [],

            totalToFill: 0,
            currentFilled: 0, // 玩家当前填了多少个

            startTime: 0,
            timerInterval: null,

            showRemaining: false
        };

        const DIRECTIONS = [
            { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }, { x: -1, y: 1 },
            { x: -1, y: 0 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }
        ];

        // --- DOM ---
        const gridEl = document.getElementById('game-grid');
        const countEl = document.getElementById('remain-count');
        const timerEl = document.getElementById('timer-display');
        const statusTextEl = document.getElementById('status-text');
        const settingsModal = document.getElementById('settings-modal');
        const tutorialModal = document.getElementById('tutorial-modal');
        const saveSelectEl = document.getElementById('save-select');
        const modeBtnEl = document.getElementById('mode-toggle-btn');

        let savedStates = [];

        // --- 核心流程 ---

        function restartGame() {
            stopTimer();

            generateLevel();
            // --- 重置回溯点 ---
            savedStates = [];

            const answerGrid = gameState.solutionGrid.map(isFill => isFill ? 1 : 0);

            savedStates.push({
                name: "reveal", // 标记名，用于判断
                grid: answerGrid,
                isReveal: true    // 核心标记：这是一个特殊档
            });

            gameState.showRemaining = false;
            // 按钮文字根据语言设定
            modeBtnEl.innerText = t('btn_show_total');

            gameState.isPlaying = true;
            gameState.currentFilled = 0;
            gameState.startTime = Date.now();

            statusTextEl.innerText = t('app_title');
            statusTextEl.className = "text-xl font-bold text-teal-800 tracking-tight";

            updateBestDisplay();

            renderGrid();
            updateUI();
            updateSaveDropdown(); // 确保下拉框重置并翻译

            // 先重置计时器显示为 00:00
            timerEl.innerText = "00:00";
            // 立即存入开局档
            saveGame();
            startTimer();
        }

        function toggleNumberDisplay() {
            // 切换状态
            gameState.showRemaining = !gameState.showRemaining;

            // 更新按钮文字 (按钮文字 = 当前模式名称)
            if (gameState.showRemaining) {
                modeBtnEl.innerText = t('btn_show_remaining');
            } else {
                modeBtnEl.innerText = t('btn_show_total');
            }

            // 刷新全盘显示
            updateAllCellsVisuals(false);
        }

        // --- 回溯点与读取系统 ---

        // 回溯点操作
        function saveGame() {
            if (!gameState.isPlaying) return;

            const currentGridJson = JSON.stringify(gameState.playerGrid);
            const currentTimeStr = timerEl.innerText;

            // 检查是否有重复盘面
            const existingIndex = savedStates.findIndex(s => JSON.stringify(s.grid) === currentGridJson);

            if (existingIndex !== -1) {
                // 如果盘面完全一样，删除旧的（为了把最新的这个加到列表末尾，或者更新它的时间名）
                savedStates.splice(existingIndex, 1);
            }

            // 添加新回溯点
            savedStates.push({
                name: currentTimeStr,
                grid: [...gameState.playerGrid] // 浅拷贝数组
            });

            updateSaveDropdown();

            // 简单的视觉反馈（可选）
            const btn = document.querySelector('#btn-save span'); // Target the span inside button
            const originalText = btn.innerText;
            btn.innerText = t('btn_saved');
            setTimeout(() => btn.innerText = t('btn_record'), 500); // Reset to translated "Save"
        }

        // 读取操作
        function loadGame() {
            if (!gameState.isPlaying) return;

            const selectedIndex = saveSelectEl.value;
            if (selectedIndex === "" || !savedStates[selectedIndex]) return;

            const record = savedStates[selectedIndex];

            // --- 新增：特殊逻辑 - 显示答案 ---
            if (record.isReveal) {
                // 覆盖盘面
                gameState.playerGrid = [...record.grid];

                // 刷新视觉
                updateAllCellsVisuals();

                // 停止游戏流程
                stopTimer();
                gameState.isPlaying = false; // 锁定游戏

                // 更新状态文字（灰色，表示放弃/结束）
                statusTextEl.innerText = t('status_revealed');
                statusTextEl.className = "text-xl font-bold text-gray-500 tracking-tight";

                countEl.innerText = "0";
                countEl.classList.remove('text-red-600');
                countEl.classList.add('text-teal-600');

                // 直接返回，不执行 checkWin，因此不会触发胜利动画和记录
                return;
            }

            // 覆盖当前盘面
            gameState.playerGrid = [...record.grid];

            // 重新计算已填色数量 (重要：防止计数器出错)
            gameState.currentFilled = gameState.playerGrid.filter(state => state === 1).length;

            // 刷新界面
            updateAllCellsVisuals();
            updateUI();
            checkWin(); // 检查读取后是否直接获胜
        }

        // 更新下拉框 UI
        function updateSaveDropdown() {
            saveSelectEl.innerHTML = `<option value="" disabled selected>${t('opt_default')}</option>`;

            // 倒序遍历，让最新的在最上面 (这里列表逻辑按照原版：最新在底部? 原版是按 push 顺序，HTML默认渲染是自上而下)
            // 原版 savedStates.forEach 是按顺序 appendChild，所以最新的在最下面。
            savedStates.forEach((state, index) => {
                const option = document.createElement('option');
                option.value = index;
                // 显示格式：序号. 时间 (例如: 1. 00:45) 或 1. 显示答案
                const displayName = state.isReveal ? t('opt_reveal') : state.name;
                option.innerText = `${index + 1}. ${displayName}`;
                saveSelectEl.appendChild(option);
            });

            // 自动选中最新的一项
            if (savedStates.length > 0) {
                saveSelectEl.value = savedStates.length - 1;
            }
        }

        function startTimer() {
            timerEl.innerText = "00:00";
            gameState.timerInterval = setInterval(() => {
                const delta = Math.floor((Date.now() - gameState.startTime) / 1000);
                timerEl.innerText = formatTime(delta);
            }, 1000);
        }

        function stopTimer() {
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
        }

        // --- 记录系统 ---

        // 1. 时间格式化工具 (秒 -> MM:SS)
        function formatTime(totalSeconds) {
            const m = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const s = (totalSeconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        // 2. 生成存储 Key (格式: sr_record_宽_高_密度)
        function getRecordKey() {
            // 密度存整数 (e.g. 0.55 -> 55) 以避免浮点精度问题
            const d = Math.round(CONFIG.fillDensity * 100);
            return `sr_rec_${CONFIG.width}_${CONFIG.height}_${d}`;
        }

        // 3. 读取并刷新 UI 显示
        function updateBestDisplay() {
            const key = getRecordKey();
            const best = localStorage.getItem(key);
            const el = document.getElementById('best-time-display');

            if (best) {
                el.innerText = formatTime(parseInt(best));
                el.classList.remove('text-gray-400');
                el.classList.add('text-amber-500'); // 有记录时显示金色/琥珀色
            } else {
                el.innerText = "--:--";
                el.classList.add('text-gray-400');
                el.classList.remove('text-amber-500');
            }
        }

        // 4. 保存记录 (如果是新纪录则返回 true)
        function trySaveRecord(seconds) {
            const key = getRecordKey();
            const currentBest = localStorage.getItem(key);

            // 如果没有记录，或者新成绩更快 (时间更短)
            if (!currentBest || seconds < parseInt(currentBest)) {
                localStorage.setItem(key, seconds);
                updateBestDisplay();
                return true;
            }
            return false;
        }

        // 计算某个格子在指定网格状态下的数值
        // 规则：数字为邻格朝8个方向延伸的连续填色格的总数（如果自己是填色格就+1）
        function calculateConnection(idx, gridRef) {
            const w = CONFIG.width;
            const h = CONFIG.height;
            const sx = idx % w;
            const sy = Math.floor(idx / w);

            // 统一判断 "是否填色"
            // solutionGrid 是 boolean
            // playerGrid: 1=Filled, 0/3=Empty
            const checkFilled = (i) => {
                const val = gridRef[i];
                if (typeof val === 'boolean') return val;
                return val === 1;
            };

            // 如果自己是填色格，初始为1，否则为0
            let count = checkFilled(idx) ? 1 : 0;

            for (let dir of DIRECTIONS) {
                let tx = sx + dir.x;
                let ty = sy + dir.y;
                while (tx >= 0 && tx < w && ty >= 0 && ty < h) {
                    const tidx = ty * w + tx;

                    if (checkFilled(tidx)) {
                        count++;
                        tx += dir.x;
                        ty += dir.y;
                    } else {
                        break;
                    }
                }
            }
            return count;
        }

        function generateLevel() {
            const w = CONFIG.width;
            const h = CONFIG.height;
            const size = w * h;

            gameState.solutionGrid = new Array(size).fill(false);
            gameState.playerGrid = new Array(size).fill(0);
            gameState.targetValues = new Array(size).fill(0);

            // 1. 生成随机答案
            const K = Math.max(0, Math.min(size, Math.round(size * CONFIG.fillDensity)));
            const idxs = Array.from({ length: size }, (_, i) => i);

            // 洗牌
            for (let i = size - 1; i > 0; i--) {
                const j = (Math.random() * (i + 1)) | 0;
                [idxs[i], idxs[j]] = [idxs[j], idxs[i]];
            }

            // 填入前K个
            for (let i = 0; i < K; i++) {
                gameState.solutionGrid[idxs[i]] = true;
            }
            gameState.totalToFill = K;

            // 2. 基于答案计算所有格子的目标数字
            for (let i = 0; i < size; i++) {
                gameState.targetValues[i] = calculateConnection(i, gameState.solutionGrid);
            }
        }

        // --- 布局逻辑 ---
        let ro = null;

        function layoutGridToFit() {
            const viewport = document.getElementById('grid-viewport');
            if (!viewport) return;

            const cols = CONFIG.width;
            const rows = CONFIG.height;
            const vr = viewport.getBoundingClientRect();
            const availW = vr.width;
            const availH = vr.height;

            const gs = getComputedStyle(gridEl);
            const gap = parseFloat(gs.gap) || 0;
            const border = parseFloat(gs.borderLeftWidth) || 0;

            const cellW = (availW - 2 * border - (cols - 1) * gap) / cols;
            const cellH = (availH - 2 * border - (rows - 1) * gap) / rows;
            const cell = Math.max(1, Math.min(cellW, cellH));

            gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cell}px)`;
            gridEl.style.gridTemplateRows = `repeat(${rows}, ${cell}px)`;

            const gridW = cols * cell + (cols - 1) * gap + 2 * border;
            const gridH = rows * cell + (rows - 1) * gap + 2 * border;

            gridEl.style.width = `${gridW}px`;
            gridEl.style.height = `${gridH}px`;
            gridEl.style.setProperty('--cell', `${cell}px`);
        }

        // --- 渲染 ---
        function renderGrid() {
            gridEl.innerHTML = '';
            for (let i = 0; i < CONFIG.width * CONFIG.height; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell unknown';
                cell.dataset.index = i;
                cell.onpointerdown = handlePointerDown; // 记录按下
                gridEl.appendChild(cell);
                updateCellView(i);
            }
            requestAnimationFrame(layoutGridToFit);
        }

        function updateCellView(idx, recolor = true) {
            const cell = gridEl.children[idx];
            if (!cell) return;

            const state = gameState.playerGrid[idx];
            const target = gameState.targetValues[idx];

            if (recolor) {
                // 基础样式重置
                cell.className = 'cell';

                // 状态样式
                if (state === 0) {
                    cell.classList.add('unknown');
                } else if (state === 1) {
                    cell.classList.add('filled');
                } else if (state === 3) {
                    cell.classList.add('marked-empty');
                }
            }

            // 检查数字状态 (蓝色高亮 or 红色警告)
            const currentVal = calculateConnection(idx, gameState.playerGrid);

            // 显示数字 (所有格子都显示)
            if (gameState.showRemaining) {
                // 显示剩余模式：目标 - 当前
                const diff = target - currentVal;
                cell.innerText = diff; // 允许负数
            } else {
                // 显示总数模式：显示原始目标
                cell.innerText = target;
            }

            if (recolor) {
                if (currentVal > target) {
                    cell.classList.add('overloaded'); // 红色
                } else if (currentVal === target) {
                    cell.classList.add('satisfied'); // 蓝色
                }
            }
        }

        function updateAllCellsVisuals(recolor = true) {
            for (let i = 0; i < gameState.playerGrid.length; i++) {
                updateCellView(i, recolor);
            }
        }

        function updateUI() {
            // 计算剩余数量（允许负数）
            const remaining = gameState.totalToFill - gameState.currentFilled;

            countEl.innerText = remaining;

            // 逻辑：小于0时变红，否则恢复原本的青色
            if (remaining < 0) {
                countEl.classList.remove('text-teal-600');
                countEl.classList.add('text-red-600'); // 红色警示
            } else {
                countEl.classList.remove('text-red-600');
                countEl.classList.add('text-teal-600'); // 恢复原色
            }
        }

        // --- 交互逻辑 ---

        let pointerDownTarget = null;
        let pointerDownButton = 0; // 0: Left, 2: Right
        let pointerType = 'mouse'; // 默认为 mouse

        // --- 移动端单指滑动标记（带双指缩放窗口期） ---
        const DRAG_ARM_DELAY = 120;       // 给第二根手指的“窗口期”(ms)
        const DRAG_MOVE_THRESHOLD = 8;    // 超过多少像素算“开始拖动”

        let activeTouchIds = new Set();

        let touchDrag = {
            id: null,
            armed: false,        // 窗口期结束后才会 armed
            dragging: false,     // 是否已进入拖动批量标记
            startX: 0,
            startY: 0,
            startTime: 0,
            action: 3,           // 3=标记空白；也可以实现擦除 0
            visited: new Set(),  // 走过的格子，避免重复处理
            armTimer: null,
            rafPending: false
        };

        function resetTouchDrag() {
            if (touchDrag.armTimer) clearTimeout(touchDrag.armTimer);
            touchDrag.id = null;
            touchDrag.armed = false;
            touchDrag.dragging = false;
            touchDrag.visited.clear();
            touchDrag.armTimer = null;
            touchDrag.rafPending = false;
        }

        function scheduleFullRefresh() {
            if (touchDrag.rafPending) return;
            touchDrag.rafPending = true;
            requestAnimationFrame(() => {
                touchDrag.rafPending = false;
                updateAllCellsVisuals();
                updateUI();
                checkWin();
            });
        }

        function applyDragMarkAtPoint(clientX, clientY) {
            const el = document.elementFromPoint(clientX, clientY);
            const cellEl = el && el.closest ? el.closest('.cell') : null;
            if (!cellEl) return;

            const idx = parseInt(cellEl.dataset.index, 10);
            if (touchDrag.visited.has(idx)) return;
            touchDrag.visited.add(idx);

            const state = gameState.playerGrid[idx];

            // 拖动只处理 0 <-> 3，避免误伤已填色(1)
            if (state === 1) return;

            const newState = touchDrag.action; // 3 或 0
            if (newState === state) return;

            gameState.playerGrid[idx] = newState;
            // 这里不改 currentFilled，因为我们不动 state=1

            scheduleFullRefresh();
        }

        function handlePointerDown(e) {
            if (!gameState.isPlaying) return;

            pointerDownTarget = e.currentTarget;
            pointerDownButton = e.button;
            pointerType = e.pointerType || 'mouse';

            // 仅移动端：准备进入“单指滑动标记”
            if (pointerType === 'touch' || pointerType === 'pen') {
                // 记录第一指
                touchDrag.id = e.pointerId;
                touchDrag.startX = e.clientX;
                touchDrag.startY = e.clientY;
                touchDrag.startTime = Date.now();
                touchDrag.dragging = false;
                touchDrag.armed = false;
                touchDrag.visited.clear();

                // 小增强：从 3 开始拖动 => 当作“擦除(0)”，否则“标记(3)”
                const idx = parseInt(pointerDownTarget.dataset.index, 10);
                touchDrag.action = (gameState.playerGrid[idx] === 3) ? 0 : 3;

                if (touchDrag.armTimer) clearTimeout(touchDrag.armTimer);
                touchDrag.armTimer = setTimeout(() => {
                    // 窗口期结束：如果仍只有一根手指，并且这根手指还在
                    if (touchDrag.id === e.pointerId && activeTouchIds.size === 1) {
                        touchDrag.armed = true;
                    }
                }, DRAG_ARM_DELAY);
            }
        }

        function handleGlobalPointerUp(e) {
            // 如果刚刚是拖动批量标记，不要当作一次“点击”
            if (touchDrag.dragging && e.pointerId === touchDrag.id) {
                pointerDownTarget = null;
                return;
            }

            if (!gameState.isPlaying || !pointerDownTarget) {
                pointerDownTarget = null;
                return;
            }

            const target = document.elementFromPoint(e.clientX, e.clientY);

            if (target === pointerDownTarget) {
                const idx = parseInt(pointerDownTarget.dataset.index);
                handleCellInteraction(idx, pointerDownButton, pointerType);
            }

            pointerDownTarget = null;
        }

        function neighborhoodHasSatisfiedOrOverloaded(idx) {
            const w = CONFIG.width;
            const h = CONFIG.height;

            const x = idx % w;
            const y = Math.floor(idx / w);

            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;

                    const j = ny * w + nx;
                    const target = gameState.targetValues[j];
                    const cur = calculateConnection(j, gameState.playerGrid);

                    // 蓝(=) 或 红(>) 都算
                    if (cur >= target) return true;
                }
            }
            return false;
        }

        function handleCellInteraction(idx, button, type) {
            const state = gameState.playerGrid[idx];
            let newState = state;

            // 逻辑分支：触摸 vs 鼠标
            if (type === 'touch' || type === 'pen') {
                const state = gameState.playerGrid[idx];
                
                if (state === 0) newState = 1;
                else if (state === 1) newState = 3;
                else if (state === 3) newState = 0;
            } else {

                // 电脑端逻辑 (mouse)
                if (button === 2) {
                    // 右键：标记空 <-> 未知
                    if (state === 0) newState = 3;
                    else newState = 0;
                } else {
                    // 左键：填色 <-> 未知
                    if (state === 0) newState = 1;
                    else newState = 0;
                }
            }

            // 更新状态
            if (newState !== state) {
                gameState.playerGrid[idx] = newState;

                // 维护计数
                if (state === 1) gameState.currentFilled--;
                if (newState === 1) gameState.currentFilled++;

                updateAllCellsVisuals(); // 全局刷新
                updateUI();
                checkWin();
            }
        }

        function checkWin() {
            // 条件1: 剩余数量为0
            if (gameState.totalToFill !== gameState.currentFilled) return;

            // 条件2: 场上所有数字都达标
            let allSatisfied = true;
            for (let i = 0; i < gameState.playerGrid.length; i++) {
                const current = calculateConnection(i, gameState.playerGrid);
                const target = gameState.targetValues[i];
                if (current !== target) {
                    allSatisfied = false;
                    break;
                }
            }

            if (allSatisfied) {
                stopTimer();
                gameState.isPlaying = false;

                const finalSeconds = Math.floor((Date.now() - gameState.startTime) / 1000);
                const isNewRecord = trySaveRecord(finalSeconds);

                // 胜利特效
                const cells = document.querySelectorAll('.cell.filled');
                cells.forEach((c, i) => {
                    setTimeout(() => c.classList.add('win-anim'), i * 5);
                });

                if (isNewRecord) {
                    statusTextEl.innerText = t('status_new_record');
                    statusTextEl.className = "text-xl font-bold text-amber-500 tracking-tight";
                } else {
                    statusTextEl.innerText = t('status_perfect');
                    statusTextEl.className = "text-xl font-bold text-teal-600 tracking-tight";
                }
            }
        }

        // --- 辅助 UI ---
        function toggleSettings() {
            settingsModal.classList.toggle('hidden');
        }

        // URL 参数管理 ---

        // 将当前 Slider 的值同步到 URL
        function updateUrlFromInputs(useReplace = false) {
            const w = document.getElementById('input-width').value;
            const h = document.getElementById('input-height').value;
            const d = document.getElementById('input-density').value;

            const url = new URL(window.location);
            url.searchParams.set('w', w);
            url.searchParams.set('h', h);
            url.searchParams.set('d', d);

            const state = { w, h, d };

            if (useReplace) {
                // 替换当前 URL (用于初始化默认值)
                window.history.replaceState(state, '', url);
            } else {
                // 推入新历史 (用于用户修改设置)
                window.history.pushState(state, '', url);
            }
        }

        // 2. 从 URL 读取参数并更新到 Slider 输入框和显示文本
        function loadInputsFromUrl() {
            const params = new URLSearchParams(window.location.search);

            const w = params.get('w');
            const h = params.get('h');
            const d = params.get('d');

            if (w) {
                document.getElementById('input-width').value = w;
                document.getElementById('val-w').innerText = w;
            }
            if (h) {
                document.getElementById('input-height').value = h;
                document.getElementById('val-h').innerText = h;
            }
            if (d) {
                document.getElementById('input-density').value = d;
                document.getElementById('val-d').innerText = d + '%';
            }

            // 只要有一个参数存在，就视为有参数
            return !!(w || h || d);
        }

        function applySettings(updateHistory = true) {
            if (updateHistory) {
                updateUrlFromInputs();
            }

            // 从 DOM 读取值应用到全局配置
            CONFIG.width = parseInt(document.getElementById('input-width').value);
            CONFIG.height = parseInt(document.getElementById('input-height').value);
            CONFIG.fillDensity = parseInt(document.getElementById('input-density').value) / 100;

            // 如果模态框是打开的，关掉它
            if (!settingsModal.classList.contains('hidden')) {
                toggleSettings();
            }

            restartGame();
        }

        // --- 辅助 UI ---
        function toggleTutorial() {
            tutorialModal.classList.toggle('hidden');

            // 互斥逻辑：如果打开教程时设置开着，就关掉设置
            if (!tutorialModal.classList.contains('hidden') && !settingsModal.classList.contains('hidden')) {
                toggleSettings();
            }
        }

        // 4. 新增：监听浏览器前进/后退事件
        window.onpopstate = function (event) {
            // 当点击后退/前进时，重新从 URL 读取参数到 Input
            loadInputsFromUrl();
            // 应用设置，但传入 false 防止死循环（不再 pushState）
            applySettings(false);
        };

        window.onload = function () {
            // 1. 尝试从 URL 读取参数
            const hasParams = loadInputsFromUrl();

            // 2. 如果 URL 没有任何参数（首次进入），则把 Input 的默认值同步到 URL
            // 使用 replaceState，这样用户点浏览器“后退”不会卡在这里
            if (!hasParams) {
                updateUrlFromInputs(true);
            }

            // 3. 应用设置并开始游戏
            // 传入 false，因为 URL 刚才已经被我们处理过了（要么是读取的，要么是补全的），不需要再 pushState
            applySettings(false);
            
            // 4. 初始化语言
            updateLanguageUI();

            // 事件监听
            document.addEventListener('pointerup', handleGlobalPointerUp);

            function endTouchPointer(e) {
                if (e.pointerType === 'touch' || e.pointerType === 'pen') {
                    activeTouchIds.delete(e.pointerId);
                }
                // 如果结束的是当前拖动手指，清理状态
                if (e.pointerId === touchDrag.id) {
                    resetTouchDrag();
                }
            }

            ro = new ResizeObserver(() => layoutGridToFit());
            ro.observe(document.getElementById('grid-viewport'));

            if (window.visualViewport) {
                visualViewport.addEventListener('resize', layoutGridToFit);
                visualViewport.addEventListener('scroll', layoutGridToFit);
            }

            // 桌面：禁用 dblclick 放大（不影响滚轮缩放等）
            document.addEventListener('dblclick', (e) => {
                e.preventDefault();
            }, { passive: false });

            // 移动端：只禁用“双点放大”，同时保证双点仍然等价于“点两次”
            let lastTapTime = 0;
            let lastTapX = 0;
            let lastTapY = 0;

            // 移动端：用 touchmove 实现“单指滑动标记空白”，并给 pinch 留窗口期
            function getTouchById(touchList, id) {
                for (const t of touchList) if (t.identifier === id) return t;
                return null;
            }

            gridEl.addEventListener('touchstart', (e) => {
                if (!gameState.isPlaying) return;

                // 不是单指：直接放行（pinch/多指）
                if (e.touches.length !== 1) {
                    resetTouchDrag();
                    return;
                }

                const t = e.touches[0];
                touchDrag.id = t.identifier;
                touchDrag.startX = t.clientX;
                touchDrag.startY = t.clientY;
                touchDrag.startTime = Date.now();
                touchDrag.dragging = false;
                touchDrag.armed = false;
                touchDrag.visited.clear();

                // 从 3 开始拖 => 擦除到 0；否则拖 => 标记到 3
                const el = document.elementFromPoint(t.clientX, t.clientY);
                const cellEl = el && el.closest ? el.closest('.cell') : null;
                if (cellEl) {
                    const idx = parseInt(cellEl.dataset.index, 10);
                    touchDrag.action = (gameState.playerGrid[idx] === 3) ? 0 : 3;
                } else {
                    touchDrag.action = 3;
                }

                if (touchDrag.armTimer) clearTimeout(touchDrag.armTimer);
                touchDrag.armTimer = setTimeout(() => {
                    // 窗口期结束时仍然是单指，才允许进入拖动
                    if (touchDrag.id === t.identifier) touchDrag.armed = true;
                }, DRAG_ARM_DELAY);

            }, { passive: true });

            gridEl.addEventListener('touchmove', (e) => {
                if (!gameState.isPlaying) return;
                if (touchDrag.id == null) return;

                // 多指：放行 pinch，并取消本次拖动候选
                if (e.touches.length !== 1) {
                    resetTouchDrag();
                    pointerDownTarget = null; // 避免 pinch 结束触发点按循环
                    return;
                }

                const t = getTouchById(e.touches, touchDrag.id) || e.touches[0];

                const dx = t.clientX - touchDrag.startX;
                const dy = t.clientY - touchDrag.startY;
                const dist2 = dx * dx + dy * dy;

                // 没进入拖动前：必须 armed + 超过阈值
                if (!touchDrag.dragging) {
                    if (!touchDrag.armed) return;
                    if (dist2 < DRAG_MOVE_THRESHOLD * DRAG_MOVE_THRESHOLD) return;

                    touchDrag.dragging = true;

                    // 一旦开始拖动：取消 pointer 的“点按”判定
                    pointerDownTarget = null;

                    // 起点也算（先标一下）
                    applyDragMarkAtPoint(touchDrag.startX, touchDrag.startY);
                }

                // 拖动中：阻止页面滚动/橡皮筋（但仅单指拖动时）
                e.preventDefault();

                applyDragMarkAtPoint(t.clientX, t.clientY);

            }, { passive: false });

            gridEl.addEventListener('touchend', (e) => {
                // 所有手指抬起：结束
                if (e.touches.length === 0) resetTouchDrag();
            }, { passive: true });

            gridEl.addEventListener('touchcancel', () => {
                resetTouchDrag();
            }, { passive: true });

        };
    </script>
</body>

</html>
